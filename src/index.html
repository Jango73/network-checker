<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Network Connection Checker</title>
  <link rel="stylesheet" href="index.css">
  <script src="../lib/react.production.min.js"></script>
  <script src="../lib/react-dom.production.min.js"></script>
  <script src="../lib/babel.min.js"></script>
  <script src="../lib/i18next.min.js"></script>
  <script src="../lib/axios.min.js"></script>
</head>
<body class="light">
  <div id="root"></div>
  <script type="text/babel" src="Map.js"></script>
  <script type="text/babel" src="config.js"></script>
  <script type="text/babel" src="utils.js"></script>
  <script type="text/babel" src="Tabs.js"></script>
  <script type="text/babel">
    window.$RefreshReg$ = () => {};
    window.$RefreshSig$ = () => () => {};

    const { useState, useEffect } = React;
    const { ipcRenderer } = window.electron;
    const { DEFAULT_CONFIG } = window.config;
    const { scanConnections, handleBannedIPsChange, handleRiskyProvidersChange, handleCountryClick, handleExport, handleClearHistory, handleResetSettings } = window.utils;

    const App = () => {
      const [connections, setConnections] = useState([]);
      const [riskyCountries, setRiskyCountries] = useState(DEFAULT_CONFIG.riskyCountries);
      const [bannedIPs, setBannedIPs] = useState(DEFAULT_CONFIG.bannedIPs);
      const [trustedIPs, setTrustedIPs] = useState(DEFAULT_CONFIG.trustedIPs);
      const [riskyProviders, setRiskyProviders] = useState(DEFAULT_CONFIG.riskyProviders);
      const [trustedProcesses, setTrustedProcesses] = useState(DEFAULT_CONFIG.trustedProcesses);
      const [intervalMin, setIntervalMin] = useState(DEFAULT_CONFIG.intervalMin);
      const [maxHistorySize, setMaxHistorySize] = useState(DEFAULT_CONFIG.maxHistorySize);
      const [isDarkMode, setIsDarkMode] = useState(DEFAULT_CONFIG.isDarkMode);
      const [isScanning, setIsScanning] = useState(false);
      const [language, setLanguage] = useState(DEFAULT_CONFIG.language);
      const [periodicScan, setPeriodicScan] = useState(DEFAULT_CONFIG.periodicScan);
      const [scanMode, setScanMode] = useState(DEFAULT_CONFIG.scanMode);
      const [activeTab, setActiveTab] = useState('main');
      const [configLoaded, setConfigLoaded] = useState(false);
      const [messages, setMessages] = useState([]);
      const [scanProgress, setScanProgress] = useState({ current: 0, total: 0 });
      const [ipError, setIpError] = useState('');
      const [providerError, setProviderError] = useState('');
      const [history, setHistory] = useState([]);
      const [i18nLoaded, setI18nLoaded] = useState(false);
      const [i18nKey, setI18nKey] = useState(0);
      const [tabsLoaded, setTabsLoaded] = useState(false);

      const addMessage = (key, type = 'error', interpolation = {}) => {
        let text;
        if (i18nLoaded && i18next.isInitialized) {
          if (i18next.exists(key)) {
            text = i18next.t(key, interpolation);
            const hasUnresolved = /\{[^}]+\}/.test(text);
            if (hasUnresolved) {
              text = `Interpolation error: ${key}`;
            }
          } else {
            text = `Missing translation: ${key}`;
          }
        } else {
          text = interpolation.ip ? `Fallback: ${key} (${interpolation.ip})` : key;
        }
        setMessages(prev => [...prev, { text, type, id: Date.now() }]);
      };

      useEffect(() => {
        if (window.Tabs && window.Tabs.Tabs && window.Tabs.renderConnectionsTable) {
          setTabsLoaded(true);
        } else {
          console.error('Tabs components not loaded');
          addMessage('Tabs components not loaded', 'error');
        }
      }, []);

      useEffect(() => {
        async function initI18n() {
          try {
            const response = await fetch('../data/translations.json');
            if (!response.ok) throw new Error('Failed to load translations');
            const translations = await response.json();
            await i18next.init({
              lng: language,
              resources: translations,
              interpolation: {
                escapeValue: false
              }
            });
            setI18nLoaded(true);
          } catch (error) {
            console.error('Failed to load translations:', error);
            addMessage('Failed to load translations. Using fallback language.', 'error');
            await i18next.init({
              lng: 'en',
              resources: {
                en: {
                  translation: {
                    appTitle: 'Network Connection Checker',
                    check: 'Check Now',
                    interval: 'Check Interval (min)',
                    periodic: 'Enable Periodic Checks',
                    countriesRisky: 'Risky Countries',
                    bannedIPs: 'Banned IPs',
                    riskyProviders: 'Risky Providers',
                    connectionsByCountry: 'Connections by Country',
                    darkMode: 'Dark Mode',
                    loading: 'Checking...',
                    noConnections: 'No active connections found.',
                    riskyConnection: 'Risky connection!',
                    invalidIP: 'Invalid IP address',
                    invalidProvider: 'Provider name must be at least 3 characters',
                    apiError: 'API error: Too many requests or connection issue. Try again later.',
                    history: 'History',
                    clearHistory: 'Clear History',
                    maxHistorySize: 'Max History Size (MB)',
                    scanDate: 'Scan Date',
                    totalConnections: 'Total Connections',
                    riskyConnections: 'Risky Connections',
                    exportJSON: 'Export as JSON',
                    exportCSV: 'Export as CSV',
                    exportSuccess: 'History exported successfully to {filePath}',
                    exportError: 'Failed to export history',
                    exportCanceled: 'Export canceled',
                    main: 'Main',
                    settings: 'Settings',
                    connections: 'Connections',
                    scannedIPs: 'Scanned IPs',
                    scanDetails: 'Scan Details',
                    country: 'Country',
                    isp: 'ISP',
                    org: 'Organization',
                    process: 'Process',
                    risky: 'Risky',
                    suspicious: 'Suspicious',
                    language: 'Language',
                    resetSettings: 'Reset to Defaults',
                    resetSuccess: 'Settings reset to defaults successfully',
                    resetError: 'Failed to reset settings',
                    noHistory: 'No scan history available',
                    map: 'Map',
                    about: 'About',
                    scanMode: 'Scan Mode',
                    liveMode: 'Live Mode',
                    testMode: 'Test Mode',
                    mark_ip_safe: 'Mark IP as Safe',
                    mark_process_safe: 'Mark Process as Safe',
                    trusted_ips: 'Trusted IPs',
                    trusted_processes: 'Trusted Processes',
                    error: {
                      no_path: 'No executable path found',
                      suspect_path: 'Suspicious executable path',
                      unexpected_path: 'Unexpected executable path'
                    },
                    warning: {
                      suspicious_process: 'Suspicious process: {processName} at {executablePath} ({reason})',
                      risky_connection: 'Risky connection detected for IP {ip}'
                    }
                  }
                }
              }
            });
            setI18nLoaded(true);
          }
        }
        if (tabsLoaded) {
          initI18n();
        }
      }, [tabsLoaded]);

      useEffect(() => {
        if (i18nLoaded && language !== i18next.language) {
          i18next.changeLanguage(language);
        }
      }, [language, i18nLoaded]);

      useEffect(() => {
        const handleLanguageChange = () => {
          setI18nKey(prev => prev + 1);
        };
        i18next.on('languageChanged', handleLanguageChange);
        return () => {
          i18next.off('languageChanged', handleLanguageChange);
        };
      }, []);

      useEffect(() => {
        async function loadConfig() {
          try {
            const config = await ipcRenderer.invoke('load-config');
            if (config) {
              setRiskyCountries(config.riskyCountries || DEFAULT_CONFIG.riskyCountries);
              setBannedIPs(config.bannedIPs || DEFAULT_CONFIG.bannedIPs);
              setTrustedIPs(config.trustedIPs || DEFAULT_CONFIG.trustedIPs);
              setRiskyProviders(config.riskyProviders || DEFAULT_CONFIG.riskyProviders);
              setTrustedProcesses(config.trustedProcesses || DEFAULT_CONFIG.trustedProcesses);
              setIntervalMin(config.intervalMin || DEFAULT_CONFIG.intervalMin);
              setMaxHistorySize(config.maxHistorySize || DEFAULT_CONFIG.maxHistorySize);
              setIsDarkMode(!!config.isDarkMode);
              setLanguage(config.language || DEFAULT_CONFIG.language);
              setPeriodicScan(config.periodicScan !== false);
              setScanMode(config.scanMode || DEFAULT_CONFIG.scanMode);
              setConfigLoaded(true);
            }
          } catch (error) {
            console.error('Failed to load config:', error);
            addMessage('Failed to load configuration.', 'error');
          }
        }
        if (tabsLoaded) {
          loadConfig();
        }
      }, [tabsLoaded]);

      useEffect(() => {
        document.body.className = isDarkMode ? 'dark' : 'light';
      }, [isDarkMode]);

      useEffect(() => {
        if (!configLoaded) return;
        async function saveConfig() {
          try {
            await ipcRenderer.invoke('save-config', {
              riskyCountries,
              bannedIPs,
              trustedIPs,
              riskyProviders,
              trustedProcesses,
              intervalMin,
              maxHistorySize,
              isDarkMode,
              language,
              periodicScan,
              scanMode
            });
          } catch (error) {
            console.error('Failed to save config:', error);
            addMessage('Failed to save configuration.', 'error');
          }
        }
        saveConfig();
      }, [riskyCountries, bannedIPs, trustedIPs, riskyProviders, trustedProcesses, intervalMin, maxHistorySize, isDarkMode, language, periodicScan, scanMode, configLoaded]);

      useEffect(() => {
        if (periodicScan && intervalMin > 0) {
          const interval = setInterval(() => {
            scanConnections(
              setConnections,
              setIsScanning,
              setScanProgress,
              addMessage,
              bannedIPs,
              riskyCountries,
              riskyProviders,
              maxHistorySize,
              i18next,
              scanMode,
              trustedIPs,
              trustedProcesses
            ).then(setHistory);
          }, intervalMin * 60 * 1000);
          return () => clearInterval(interval);
        }
      }, [periodicScan, intervalMin, bannedIPs, riskyCountries, riskyProviders, maxHistorySize, scanMode, trustedIPs, trustedProcesses]);

      useEffect(() => {
        if (messages.length > 0) {
          const timer = setTimeout(() => {
            setMessages(prev => prev.slice(1));
          }, 10000);
          return () => clearTimeout(timer);
        }
      }, [messages]);

      useEffect(() => {
        async function loadHistory() {
          try {
            const historyData = await ipcRenderer.invoke('load-history');
            setHistory(historyData || []);
          } catch (error) {
            console.error('Failed to load history:', error);
            addMessage('Failed to load scan history.', 'error');
          }
        }
        if (tabsLoaded) {
          loadHistory();
        }
      }, [tabsLoaded]);

      if (!i18nLoaded || !tabsLoaded) {
        return <div>Loading...</div>;
      }

      return (
        <div className={isDarkMode ? 'dark' : 'light'} key={i18nKey}>
          <h1>{i18next.t('appTitle')}</h1>
          {messages.length > 0 && (
            <div className="messages">
              {messages.map(msg => (
                <div key={msg.id} className={msg.type}>
                  {msg.text}
                </div>
              ))}
            </div>
          )}
          <window.Tabs.Tabs activeTab={activeTab} setActiveTab={setActiveTab} i18next={i18next} />
          {activeTab === 'main' && (
            <window.Tabs.MainContent
              connections={connections}
              isScanning={isScanning}
              scanConnections={() => scanConnections(
                setConnections,
                setIsScanning,
                setScanProgress,
                addMessage,
                bannedIPs,
                riskyCountries,
                riskyProviders,
                maxHistorySize,
                i18next,
                scanMode,
                trustedIPs,
                trustedProcesses
              )}
              periodicScan={periodicScan}
              setPeriodicScan={setPeriodicScan}
              scanProgress={scanProgress}
              i18next={i18next}
            />
          )}
          {activeTab === 'map' && (
            <window.Tabs.MapContent
              connections={connections}
              isDarkMode={isDarkMode}
              i18next={i18next}
            />
          )}
          {activeTab === 'history' && (
            <window.Tabs.HistoryContent
              history={history}
              handleExport={format => handleExport(format, addMessage, i18next)}
              handleClearHistory={() => handleClearHistory(setHistory, addMessage, i18next)}
              i18next={i18next}
            />
          )}
          {activeTab === 'settings' && (
            <window.Tabs.SettingsContent
              language={language}
              setLanguage={setLanguage}
              isDarkMode={isDarkMode}
              setIsDarkMode={setIsDarkMode}
              intervalMin={intervalMin}
              setIntervalMin={setIntervalMin}
              maxHistorySize={maxHistorySize}
              setMaxHistorySize={setMaxHistorySize}
              bannedIPs={bannedIPs}
              handleBannedIPsChange={e => handleBannedIPsChange(e, setBannedIPs, setIpError, i18next)}
              ipError={ipError}
              riskyProviders={riskyProviders}
              handleRiskyProvidersChange={e => handleRiskyProvidersChange(e, setRiskyProviders, setProviderError, i18next)}
              providerError={providerError}
              riskyCountries={riskyCountries}
              handleCountryClick={country => handleCountryClick(country, riskyCountries, setRiskyCountries)}
              handleResetSettings={() => handleResetSettings(
                setRiskyCountries,
                setBannedIPs,
                setRiskyProviders,
                setIntervalMin,
                setMaxHistorySize,
                setIsDarkMode,
                setLanguage,
                setPeriodicScan,
                addMessage,
                i18next,
                setScanMode,
                setTrustedIPs,
                setTrustedProcesses
              )}
              i18next={i18next}
              scanMode={scanMode}
              setScanMode={setScanMode}
              trustedIPs={trustedIPs}
              setTrustedIPs={setTrustedIPs}
              trustedProcesses={trustedProcesses}
              setTrustedProcesses={setTrustedProcesses}
            />
          )}
          {activeTab === 'about' && (
            <window.Tabs.AboutContent i18next={i18next} />
          )}
        </div>
      );
    };

    try {
      if (window.React && window.ReactDOM && document.getElementById('root')) {
        ReactDOM.render(<App />, document.getElementById('root'));
      } else {
        console.error('Cannot render: Missing dependencies or root element', {
          React: !!window.React,
          ReactDOM: !!window.ReactDOM,
          root: !!document.getElementById('root')
        });
        document.getElementById('root').innerHTML = '<p>Error: Failed to load application.</p>';
      }
    } catch (error) {
      console.error('Failed to render App:', error);
      document.getElementById('root').innerHTML = '<p>Error: Failed to load application.</p>';
    }
  </script>
</body>
</html>