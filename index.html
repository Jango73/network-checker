<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Network Connection Checker</title>
  <link rel="stylesheet" href="index.css">
  <script src="./lib/react.production.min.js"></script>
  <script src="./lib/react-dom.production.min.js"></script>
  <script src="./lib/babel.min.js"></script>
  <script src="./lib/i18next.min.js"></script>
  <script src="./lib/axios.min.js"></script>
</head>
<body class="light">
  <div id="root"></div>
  <script type="text/babel">
    window.$RefreshReg$ = () => {};
    window.$RefreshSig$ = () => () => {};

    const { useState, useEffect } = React;
    const { ipcRenderer } = window.electron;

    const countries = ['Algeria', 'Australia', 'Austria', 'Bangladesh', 'Belarus', 'Belgium', 'Canada', 'China', 'Denmark', 'Egypt', 'Finland', 'France', 'Germany', 'Ghana', 'Greece', 'Honduras', 'India', 'Iran', 'Ireland', 'Israel', 'Italy', 'Japan', 'Kenya', 'Morocco', 'Netherlands', 'New Zealand', 'Nigeria', 'Norway', 'Panama', 'Russia', 'Singapore', 'South Africa', 'South Korea', 'Spain', 'Sweden', 'Switzerland', 'Thailand', 'Ukraine', 'United Kingdom', 'United States', 'Venezuela'].sort();

    const App = () => {
      const [connections, setConnections] = useState([]);
      const [friendlyCountries, setFriendlyCountries] = useState(['France', 'United States']);
      const [riskyCountries, setRiskyCountries] = useState(['Iran', 'Bangladesh', 'Venezuela', 'Honduras', 'Algeria', 'Nigeria', 'India', 'Panama', 'Thailand', 'Belarus', 'Ukraine', 'Kenya', 'South Africa', 'Ghana']);
      const [bannedIPs, setBannedIPs] = useState([]);
      const [riskyProviders, setRiskyProviders] = useState(['Choopa', 'LeaseWeb', 'QuadraNet', 'Ecatel', 'Sharktech', 'HostSailor', 'M247', 'WorldStream']);
      const [intervalMin, setIntervalMin] = useState(30);
      const [maxHistorySize, setMaxHistorySize] = useState(10);
      const [isDarkMode, setIsDarkMode] = useState(false);
      const [isScanning, setIsScanning] = useState(false);
      const [language, setLanguage] = useState('en');
      const [periodicScan, setPeriodicScan] = useState(true);
      const [activeTab, setActiveTab] = useState('main');
      const [configLoaded, setConfigLoaded] = useState(false);
      const [errorMessage, setErrorMessage] = useState('');
      const [exportMessage, setExportMessage] = useState('');
      const [scanProgress, setScanProgress] = useState({ current: 0, total: 0 });
      const [ipError, setIpError] = useState('');
      const [providerError, setProviderError] = useState('');
      const [history, setHistory] = useState([]);
      const [selectedScan, setSelectedScan] = useState(null);
      const [i18nLoaded, setI18nLoaded] = useState(false);

      useEffect(() => {
        async function initI18n() {
          try {
            const response = await fetch('translations.json');
            if (!response.ok) throw new Error('Failed to load translations');
            const translations = await response.json();
            await i18next.init({
              lng: language,
              resources: translations,
            });
            setI18nLoaded(true);
          } catch (error) {
            console.error('Failed to load translations:', error);
            setErrorMessage('Failed to load translations. Using fallback language.');
            await i18next.init({
              lng: 'en',
              resources: {
                en: {
                  translation: {
                    appTitle: 'Network Connection Checker',
                    check: 'Check Now',
                    interval: 'Check Interval (min)',
                    periodic: 'Enable Periodic Checks',
                    countriesFriendly: 'Friendly Countries',
                    countriesRisky: 'Risky Countries',
                    bannedIPs: 'Banned IPs',
                    riskyProviders: 'Risky Providers',
                    connectionsByCountry: 'Connections by Country',
                    darkMode: 'Dark Mode',
                    loading: 'Checking...',
                    noConnections: 'No active connections found.',
                    riskyConnection: 'Risky connection!',
                    invalidIP: 'Invalid IP address',
                    invalidProvider: 'Provider name must be at least 3 characters',
                    apiError: 'API error: Too many requests or connection issue. Try again later.',
                    history: 'History',
                    clearHistory: 'Clear History',
                    maxHistorySize: 'Max History Size (MB)',
                    scanDate: 'Scan Date',
                    totalConnections: 'Total Connections',
                    riskyConnections: 'Risky Connections',
                    exportJSON: 'Export as JSON',
                    exportCSV: 'Export as CSV',
                    exportSuccess: 'History exported successfully to {filePath}',
                    exportError: 'Failed to export history',
                    exportCanceled: 'Export canceled'
                  }
                }
              }
            });
            setI18nLoaded(true);
          }
        }
        initI18n();
      }, []);

      useEffect(() => {
        if (i18nLoaded && language !== i18next.language) {
          i18next.changeLanguage(language);
        }
      }, [language, i18nLoaded]);

      useEffect(() => {
        async function loadConfig() {
          try {
            const config = await ipcRenderer.invoke('load-config');
            if (config) {
              setFriendlyCountries(config.friendlyCountries || ['France', 'United States']);
              setRiskyCountries(config.riskyCountries || ['Iran', 'Bangladesh', 'Venezuela', 'Honduras', 'Algeria', 'Nigeria', 'India', 'Panama', 'Thailand', 'Belarus', 'Ukraine', 'Kenya', 'South Africa', 'Ghana']);
              setBannedIPs(config.bannedIPs || []);
              setRiskyProviders(config.riskyProviders || ['Choopa', 'LeaseWeb', 'QuadraNet', 'Ecatel', 'Sharktech', 'HostSailor', 'M247', 'WorldStream']);
              setIntervalMin(config.intervalMin || 30);
              setMaxHistorySize(config.maxHistorySize || 10);
              setIsDarkMode(!!config.isDarkMode);
              setLanguage(config.language || 'en');
              setPeriodicScan(config.periodicScan !== false);
              setConfigLoaded(true);
            }
          } catch (error) {
            console.error('Failed to load config:', error);
            setErrorMessage('Failed to load configuration.');
          }
        }
        loadConfig();
      }, []);

      useEffect(() => {
        document.body.className = isDarkMode ? 'dark' : 'light';
      }, [isDarkMode]);

      useEffect(() => {
        if (!configLoaded) return;
        async function saveConfig() {
          try {
            await ipcRenderer.invoke('save-config', {
              friendlyCountries, 
              riskyCountries, 
              bannedIPs, 
              riskyProviders, 
              intervalMin, 
              maxHistorySize,
              isDarkMode, 
              language, 
              periodicScan
            });
          } catch (error) {
            console.error('Failed to save config:', error);
            setErrorMessage('Failed to save configuration.');
          }
        }
        saveConfig();
      }, [friendlyCountries, riskyCountries, bannedIPs, riskyProviders, intervalMin, maxHistorySize, isDarkMode, language, periodicScan, configLoaded]);

      useEffect(() => {
        if (periodicScan && intervalMin > 0) {
          const interval = setInterval(() => scanConnections(), intervalMin * 60 * 1000);
          return () => clearInterval(interval);
        }
      }, [periodicScan, intervalMin]);

      useEffect(() => {
        if (errorMessage) {
          const timer = setTimeout(() => setErrorMessage(''), 10000);
          return () => clearTimeout(timer);
        }
      }, [errorMessage]);

      useEffect(() => {
        if (exportMessage) {
          const timer = setTimeout(() => setExportMessage(''), 5000);
          return () => clearTimeout(timer);
        }
      }, [exportMessage]);

      useEffect(() => {
        async function loadHistory() {
          try {
            const historyData = await ipcRenderer.invoke('load-history');
            setHistory(historyData || []);
          } catch (error) {
            console.error('Failed to load history:', error);
            setErrorMessage('Failed to load scan history.');
          }
        }
        loadHistory();
      }, []);

      const validateIP = (ip) => {
        const ipRegex = /^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$/;
        return ipRegex.test(ip) && ip.split('.').every(num => parseInt(num) >= 0 && parseInt(num) <= 255);
      };

      const validateProvider = (provider) => {
        return provider.length >= 3;
      };

      const handleBannedIPsChange = (e) => {
        const newIPs = e.target.value.split(',').map(ip => ip.trim()).filter(ip => ip);
        const invalidIP = newIPs.find(ip => !validateIP(ip));
        if (invalidIP) {
          setIpError(i18next.t('invalidIP'));
        } else {
          setIpError('');
          setBannedIPs(newIPs);
        }
      };

      const handleRiskyProvidersChange = (e) => {
        const newProviders = e.target.value.split(',').map(p => p.trim()).filter(p => p);
        const invalidProvider = newProviders.find(p => !validateProvider(p));
        if (invalidProvider) {
          setProviderError(i18next.t('invalidProvider'));
        } else {
          setProviderError('');
          setRiskyProviders(newProviders);
        }
      };

      const handleExport = async (format) => {
        try {
          const result = await ipcRenderer.invoke('export-history', format);
          setExportMessage(i18next.t(result.success ? 'exportSuccess' : result.message === 'Export canceled' ? 'exportCanceled' : 'exportError', { filePath: result.message.includes('exported to') ? result.message.split('exported to ')[1] : '' }));
        } catch (error) {
          console.error('Failed to export history:', error);
          setExportMessage(i18next.t('exportError'));
        }
      };

      const handleClearHistory = async () => {
        try {
          await ipcRenderer.invoke('clear-history');
          setHistory([]);
          setSelectedScan(null);
        } catch (error) {
          console.error('Failed to clear history:', error);
          setErrorMessage('Failed to clear history.');
        }
      };

      const scanConnections = async () => {
        setIsScanning(true);
        setErrorMessage('');
        setScanProgress({ current: 0, total: 0 });
        try {
          const netstatOutput = await ipcRenderer.invoke('run-netstat');
          const lines = netstatOutput.split('\n').filter(line => line.includes('ESTABLISHED'));
          const ipSet = new Set(lines.map(line => {
            const parts = line.trim().split(/\s+/);
            return parts[2]?.split(':')[0];
          }).filter(ip => ip && !/^(10\.|172\.(1[6-9]|2[0-9]|3[0-1])\.|192\.168\.|127\.|::1|0\.0\.0\.0)/.test(ip)));

          const processMap = await ipcRenderer.invoke('get-process-name');

          const connections = [];
          let requestCount = 0;
          let hasPlayedSound = false;
          setScanProgress({ current: 0, total: ipSet.size });

          for (const ip of ipSet) {
            try {
              const response = await axios.get(`http://ip-api.com/json/${ip}`);
              if (response.data.status === 'success') {
                const { country, isp, org } = response.data;
                const isRisky = bannedIPs.includes(ip) || riskyCountries.includes(country) || riskyProviders.some(p => isp.includes(p) || org.includes(p));
                const line = lines.find(l => l.includes(ip));
                const parts = line.trim().split(/\s+/);
                const pid = parts[parts.length - 1];
                const processName = processMap[pid] || 'Unknown';
                connections.push({
                  ip,
                  country,
                  isp,
                  org,
                  isRisky,
                  pid: isNaN(pid) ? 'Unknown' : pid,
                  processName
                });
                if (isRisky && !hasPlayedSound) {
                  new Audio('https://freesound.org/data/previews/316/316847_4939433-lq.mp3').play();
                  hasPlayedSound = true;
                }
              }
            } catch (error) {
              console.error(`Error checking IP ${ip}:`, error);
              setErrorMessage(i18next.t('apiError'));
            }
            requestCount++;
            setScanProgress(prev => ({ ...prev, current: prev.current + 1 }));
            if (requestCount >= 45) {
              await new Promise(resolve => setTimeout(resolve, 60000));
              requestCount = 0;
            }
            await new Promise(resolve => setTimeout(resolve, 100));
          }
          setConnections(connections);

          const scanData = {
            timestamp: new Date().toISOString(),
            connections,
            totalConnections: connections.length,
            riskyConnections: connections.filter(c => c.isRisky).length
          };
          try {
            await ipcRenderer.invoke('save-history', scanData, maxHistorySize);
            const updatedHistory = await ipcRenderer.invoke('load-history');
            setHistory(updatedHistory || []);
          } catch (error) {
            console.error('Failed to save history:', error);
            setErrorMessage('Failed to save scan history.');
          }
        } catch (error) {
          console.error('Error checking:', error);
          setErrorMessage('Failed to run scan. Check network or system permissions.');
        }
        setIsScanning(false);
        setScanProgress({ current: 0, total: 0 });
      };

      const countryCounts = connections.reduce((acc, conn) => {
        acc[conn.country] = (acc[conn.country] || 0) + 1;
        return acc;
      }, {});

      const renderConnectionsTable = (conns) => {
        if (!conns || conns.length === 0) {
          return <p>{i18next.t('noConnections')}</p>;
        }
        return (
          <table>
            <thead>
              <tr>
                <th>IP</th>
                <th>Country</th>
                <th>ISP</th>
                <th>Org</th>
                <th>PID</th>
                <th>Process</th>
                <th>Risky</th>
                <th>WHOIS</th>
              </tr>
            </thead>
            <tbody>
              {conns.map(conn => (
                <tr key={conn.ip} className={conn.isRisky ? 'risky' : ''}>
                  <td>{conn.ip}</td>
                  <td>{conn.country}</td>
                  <td>{conn.isp}</td>
                  <td>{conn.org}</td>
                  <td>{conn.pid}</td>
                  <td>{conn.processName}</td>
                  <td>{conn.isRisky ? i18next.t('riskyConnection') : '-'}</td>
                  <td>
                    <a href={`https://whois.domaintools.com/${conn.ip}`} target="_blank">WHOIS</a>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        );
      };

      if (!i18nLoaded) {
        return <div>Loading translations...</div>;
      }

      return (
        <div className={isDarkMode ? 'dark' : 'light'}>
          <h1>{i18next.t('appTitle')}</h1>
          
          <div className="tabs">
            <div className={`tab ${activeTab === 'main' ? 'active' : ''}`} onClick={() => setActiveTab('main')}>
              Main
            </div>
            <div className={`tab ${activeTab === 'history' ? 'active' : ''}`} onClick={() => setActiveTab('history')}>
              {i18next.t('history')}
            </div>
            <div className={`tab ${activeTab === 'settings' ? 'active' : ''}`} onClick={() => setActiveTab('settings')}>
              Settings
            </div>
          </div>

          {activeTab === 'main' && (
            <div>
              {errorMessage && <div className="alert">{errorMessage}</div>}
              <button onClick={scanConnections} disabled={isScanning}>
                {isScanning ? <span className="spinner"></span> : i18next.t('check')}
              </button>
              {isScanning && scanProgress.total > 0 && (
                <div className="progress-container">
                  <div className="progress-bar">
                    <div
                      className="progress-fill"
                      style={{ width: `${(scanProgress.current / scanProgress.total) * 100}%` }}
                    ></div>
                  </div>
                  <div className="progress-text">
                    Scanning {scanProgress.current}/{scanProgress.total} IPs ({Math.round((scanProgress.current / scanProgress.total) * 100)}%)
                  </div>
                </div>
              )}
              <div className="form-group" style={{ marginTop: '0.625rem' }}>
                <label>
                  <input
                    type="checkbox"
                    checked={periodicScan}
                    onChange={() => setPeriodicScan(!periodicScan)}
                  />
                  {i18next.t('periodic')}
                </label>
              </div>
              <div style={{ marginTop: '1.25rem' }}>
                <h2>{i18next.t('connectionsByCountry')}</h2>
                {Object.keys(countryCounts).length > 0 ? (
                  <table>
                    <thead>
                      <tr>
                        <th>Country</th>
                        <th>Connections</th>
                      </tr>
                    </thead>
                    <tbody>
                      {Object.entries(countryCounts).map(([country, count]) => (
                        <tr key={country}>
                          <td>{country}</td>
                          <td>{count}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                ) : (
                  <p>{i18next.t('noConnections')}</p>
                )}
              </div>
              <div style={{ marginTop: '1.25rem' }}>
                <h2>Scanned IPs</h2>
                {renderConnectionsTable(connections)}
              </div>
            </div>
          )}

          {activeTab === 'history' && (
            <div>
              {errorMessage && <div className="alert">{errorMessage}</div>}
              {exportMessage && <div className={exportMessage.includes('successfully') ? 'success-message' : 'alert'}>{exportMessage}</div>}
              <button className="clear" onClick={handleClearHistory}>
                {i18next.t('clearHistory')}
              </button>
              <button className="export-json" onClick={() => handleExport('json')}>
                {i18next.t('exportJSON')}
              </button>
              <button className="export-csv" onClick={() => handleExport('csv')}>
                {i18next.t('exportCSV')}
              </button>
              <div style={{ marginTop: '1.25rem' }}>
                <h2>{i18next.t('history')}</h2>
                {history.length > 0 ? (
                  <table>
                    <thead>
                      <tr>
                        <th>{i18next.t('scanDate')}</th>
                        <th>{i18next.t('totalConnections')}</th>
                        <th>{i18next.t('riskyConnections')}</th>
                      </tr>
                    </thead>
                    <tbody>
                      {history.map((scan, index) => (
                        <tr 
                          key={scan.timestamp} 
                          className="history-row"
                          onClick={() => setSelectedScan(selectedScan?.timestamp === scan.timestamp ? null : scan)}
                        >
                          <td>{new Date(scan.timestamp).toLocaleString()}</td>
                          <td>{scan.totalConnections}</td>
                          <td>{scan.riskyConnections}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                ) : (
                  <p>No scan history available.</p>
                )}
              </div>
              {selectedScan && (
                <div style={{ marginTop: '1.25rem' }}>
                  <h2>Scan Details ({new Date(selectedScan.timestamp).toLocaleString()})</h2>
                  {renderConnectionsTable(selectedScan.connections)}
                </div>
              )}
            </div>
          )}

          {activeTab === 'settings' && (
            <div className="config">
              <div className="form-group">
                <label>Language</label>
                <select value={language} onChange={(e) => setLanguage(e.target.value)}>
                  <option value="en">English</option>
                  <option value="fr">Français</option>
                  <option value="it">Italiano</option>
                  <option value="de">Deutsch</option>
                  <option value="es">Español</option>
                  <option value="el">Ελληνικά</option>
                  <option value="ru">Русский</option>
                  <option value="zh">中文</option>
                  <option value="ko">한국어</option>
                </select>
              </div>
              <div className="form-group">
                <label>{i18next.t('darkMode')}</label>
                <input type="checkbox" checked={isDarkMode} onChange={() => setIsDarkMode(!isDarkMode)} />
              </div>
              <div className="form-group">
                <label>{i18next.t('interval')}</label>
                <input
                  type="number"
                  value={intervalMin}
                  onChange={(e) => setIntervalMin(Math.max(0, parseInt(e.target.value)))}
                />
              </div>
              <div className="form-group">
                <label>{i18next.t('maxHistorySize')}</label>
                <input
                  type="number"
                  value={maxHistorySize}
                  onChange={(e) => setMaxHistorySize(Math.max(1, parseInt(e.target.value)))}
                />
              </div>
              <div className="form-group">
                <label>{i18next.t('bannedIPs')}</label>
                <input
                  type="text"
                  value={bannedIPs.join(',')}
                  onChange={handleBannedIPsChange}
                />
                {ipError && <div className="error-message">{ipError}</div>}
              </div>
              <div className="form-group">
                <label>{i18next.t('riskyProviders')}</label>
                <input
                  type="text"
                  value={riskyProviders.join(',')}
                  onChange={handleRiskyProvidersChange}
                />
                {providerError && <div className="error-message">{providerError}</div>}
              </div>
              <div className="form-group">
                <label>{i18next.t('countriesFriendly')}</label>
                <select multiple value={friendlyCountries} onChange={(e) => setFriendlyCountries(Array.from(e.target.selectedOptions, opt => opt.value))}>
                  {countries.map(country => <option key={country} value={country}>{country}</option>)}
                </select>
              </div>
              <div className="form-group">
                <label>{i18next.t('countriesRisky')}</label>
                <select multiple value={riskyCountries} onChange={(e) => setRiskyCountries(Array.from(e.target.selectedOptions, opt => opt.value))}>
                  {countries.map(country => <option key={country} value={country}>{country}</option>)}
                </select>
              </div>
            </div>
          )}
        </div>
      );
    };

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>